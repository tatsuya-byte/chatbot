"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceClientContext = void 0;
const core_client_1 = require("@azure/core-client");
const core_http_compat_1 = require("@azure/core-http-compat");
const response_1 = require("./response");
const core_rest_pipeline_1 = require("@azure/core-rest-pipeline");
const compat_1 = require("./compat");
/**
 * Compat implementation between @azure/core-http and @azure/core-client.
 */
class ServiceClientContext {
    /**
     * Initializes a new instance of the ConnectorClientContext class.
     *
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    constructor(credentials, options = {}) {
        var _a, _b, _c, _d;
        this._requestPolicyFactories = [];
        if (credentials === null || credentials === undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        const requestContentType = ((_b = (_a = options.deserializationContentTypes) === null || _a === void 0 ? void 0 : _a.json) === null || _b === void 0 ? void 0 : _b.join(' ')) ||
            ((_d = (_c = options.deserializationContentTypes) === null || _c === void 0 ? void 0 : _c.xml) === null || _d === void 0 ? void 0 : _d.join(' ')) ||
            'application/json; charset=utf-8';
        const userAgentPrefix = (typeof options.userAgent === 'function' ? options.userAgent('') : options.userAgent) || '';
        const { baseUri: endpoint, proxySettings: proxyOptions, httpClient, credentialScopes, requestPolicyFactories, } = options;
        // do something with noPolicy option.
        this.client = new core_client_1.ServiceClient({
            endpoint,
            requestContentType,
            userAgentOptions: { userAgentPrefix },
            allowInsecureConnection: endpoint === null || endpoint === void 0 ? void 0 : endpoint.toLowerCase().startsWith('http:'),
            proxyOptions,
            httpClient: httpClient ? (0, core_http_compat_1.convertHttpClient)(httpClient) : undefined,
            credentialScopes,
        });
        this.baseUri = endpoint;
        this.requestContentType = requestContentType;
        this.credentials = credentials;
        this.options = options;
        this._requestPolicyFactories = this.addPolicies(this.client, requestPolicyFactories);
    }
    // Protects against JSON.stringify leaking secrets
    toJSON() {
        return { name: this.constructor.name };
    }
    /**
     * Send the provided httpRequest.
     *
     * @param request The HTTP request to send.
     * @returns The HTTP response.
     */
    sendRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!request) {
                throw new Error('request cannot be null');
            }
            const newRequest = yield this.addRequestSettings(request);
            const response = yield this.client.sendRequest(newRequest);
            return (0, response_1.toCompatResponse)(response);
        });
    }
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     *
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     * @param callback - The callback to call when the response is received.
     * @returns The response object.
     */
    sendOperationRequest(operationArguments, operationSpec, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!operationArguments) {
                throw new Error('operationArguments cannot be null');
            }
            const _a = operationArguments.options || {}, { customHeaders, timeout, onDownloadProgress, onUploadProgress, shouldDeserialize, serializerOptions, tracingContext } = _a, restOptions = __rest(_a, ["customHeaders", "timeout", "onDownloadProgress", "onUploadProgress", "shouldDeserialize", "serializerOptions", "tracingContext"]);
            let _response;
            const requestOptions = {};
            const operationArgumentPipeline = Object.assign(Object.assign({}, operationArguments), { options: Object.assign(Object.assign({}, restOptions), { requestOptions,
                    onResponse(rawResponse, flatResponse, error) {
                        _response = rawResponse;
                        const response = (0, response_1.toCompatResponse)(rawResponse);
                        callback === null || callback === void 0 ? void 0 : callback(error, flatResponse, response.request, response);
                    } }) });
            if (customHeaders) {
                requestOptions.customHeaders = customHeaders;
            }
            if (timeout) {
                requestOptions.timeout = timeout;
            }
            if (onDownloadProgress) {
                requestOptions.onDownloadProgress = onDownloadProgress;
            }
            if (onUploadProgress) {
                requestOptions.onUploadProgress = onUploadProgress;
            }
            if (shouldDeserialize) {
                requestOptions.shouldDeserialize = (response) => {
                    if (typeof shouldDeserialize === 'function') {
                        return shouldDeserialize((0, response_1.toCompatResponse)(response));
                    }
                    else if (typeof shouldDeserialize === 'boolean') {
                        return shouldDeserialize;
                    }
                    return true;
                };
            }
            if (serializerOptions) {
                operationArgumentPipeline.options.serializerOptions = {
                    xml: serializerOptions,
                };
            }
            if (tracingContext) {
                operationArgumentPipeline.options.tracingOptions = {
                    tracingContext,
                };
            }
            const result = yield this.client.sendOperationRequest(operationArgumentPipeline, operationSpec);
            Object.defineProperty(result, '_response', {
                value: _response,
            });
            return result;
        });
    }
    addRequestSettings(request) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const webResource = (0, compat_1.createWebResource)(request);
            yield this.credentials.signRequest(webResource);
            const headers = (0, core_rest_pipeline_1.createHttpHeaders)(Object.assign(Object.assign({}, request.headers.toJSON({ preserveCase: true })), webResource.headers.toJson({ preserveCase: true })));
            request.withCredentials = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.withCredentials) === true;
            request.headers = headers;
            return request;
        });
    }
    addPolicies(client, policies) {
        if (Array.isArray(policies)) {
            const policy = (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(policies);
            policy.name = 'ServiceClientContext_RequestPolicyFactories';
            client.pipeline.removePolicy(policy);
            client.pipeline.addPolicy(policy);
        }
        else if (typeof policies === 'function') {
            this.addPolicies(client, policies([]) || []);
        }
        this.client.pipeline.addPolicy({
            name: 'ServiceClientContext_Credentials_SignRequest',
            sendRequest: (request, next) => __awaiter(this, void 0, void 0, function* () {
                const newRequest = yield this.addRequestSettings(request);
                return next(newRequest);
            }),
        });
        return client.pipeline.getOrderedPolicies();
    }
}
exports.ServiceClientContext = ServiceClientContext;
//# sourceMappingURL=serviceClientContext.js.map