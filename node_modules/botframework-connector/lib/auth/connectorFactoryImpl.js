"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectorFactoryImpl = exports.USER_AGENT = void 0;
const connectorClient_1 = require("../connectorApi/connectorClient");
const connectorFactory_1 = require("./connectorFactory");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const packageInfo = require('../../package.json');
exports.USER_AGENT = `Microsoft-BotFramework/3.1 ${packageInfo.name}/${packageInfo.version} `;
/**
 * @internal
 * Implementation of [ConnectorFactory](xref:botframework-connector.ConnectorFactory).
 */
class ConnectorFactoryImpl extends connectorFactory_1.ConnectorFactory {
    /**
     * @param appId The AppID.
     * @param toChannelFromBotOAuthScope The to Channel from bot oauth scope.
     * @param loginEndpoint The login url.
     * @param validateAuthority The validate authority value to use.
     * @param credentialFactory A ServiceClientCredentialsFactory to use.
     * @param connectorClientOptions The [ConnectorClientOptions](xref:botframework-connector.ConnectorClientOptions) to use when creating ConnectorClients.
     */
    constructor(appId, toChannelFromBotOAuthScope, loginEndpoint, validateAuthority, credentialFactory, connectorClientOptions = {}) {
        super();
        this.appId = appId;
        this.toChannelFromBotOAuthScope = toChannelFromBotOAuthScope;
        this.loginEndpoint = loginEndpoint;
        this.validateAuthority = validateAuthority;
        this.credentialFactory = credentialFactory;
        this.connectorClientOptions = connectorClientOptions;
    }
    /**
     * @param serviceUrl The client's service URL.
     * @param audience The audience to use for outbound communication. It will vary by cloud environment.
     * @returns The new instance of the ConnectorClient class.
     */
    create(serviceUrl, audience) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Use the credentials factory to create credentails specific to this particular cloud environment.
            const credentials = yield this.credentialFactory.createCredentials(this.appId, audience !== null && audience !== void 0 ? audience : this.toChannelFromBotOAuthScope, this.loginEndpoint, this.validateAuthority);
            const userAgent = typeof ((_a = this.connectorClientOptions) === null || _a === void 0 ? void 0 : _a.userAgent) === 'function'
                ? (_b = this.connectorClientOptions) === null || _b === void 0 ? void 0 : _b.userAgent(exports.USER_AGENT)
                : (_c = this.connectorClientOptions) === null || _c === void 0 ? void 0 : _c.userAgent;
            const options = Object.assign(Object.assign({}, this.connectorClientOptions), { baseUri: serviceUrl, userAgent: `${exports.USER_AGENT} ${userAgent !== null && userAgent !== void 0 ? userAgent : ''}` });
            options.requestPolicyFactories = [
                {
                    create: (nextPolicy) => ({
                        sendRequest: (httpRequest) => {
                            if (!httpRequest.headers.contains('accept')) {
                                httpRequest.headers.set('accept', '*/*');
                            }
                            return nextPolicy.sendRequest(httpRequest);
                        },
                    }),
                },
            ];
            return new connectorClient_1.ConnectorClient(credentials, options);
        });
    }
}
exports.ConnectorFactoryImpl = ConnectorFactoryImpl;
//# sourceMappingURL=connectorFactoryImpl.js.map